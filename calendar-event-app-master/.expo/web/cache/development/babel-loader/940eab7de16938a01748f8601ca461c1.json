{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fontFamilyNeedsScoping = fontFamilyNeedsScoping;\nexports.getAssetForSource = getAssetForSource;\nexports.getNativeFontName = getNativeFontName;\nexports.loadSingleFontAsync = loadSingleFontAsync;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _expoAsset = require(\"expo-asset\");\nvar _expoModulesCore = require(\"expo-modules-core\");\nvar _ExpoFontLoader = _interopRequireDefault(require(\"./ExpoFontLoader\"));\nvar _Font = require(\"./Font\");\nfunction uriFromFontSource(asset) {\n  if (typeof asset === 'string') {\n    return asset || null;\n  } else if (typeof asset === 'object') {\n    return asset.uri || asset.localUri || asset.default || null;\n  } else if (typeof asset === 'number') {\n    return uriFromFontSource(_expoAsset.Asset.fromModule(asset));\n  }\n  return null;\n}\nfunction displayFromFontSource(asset) {\n  return asset.display || _Font.FontDisplay.AUTO;\n}\nfunction fontFamilyNeedsScoping(name) {\n  return false;\n}\nfunction getAssetForSource(source) {\n  var uri = uriFromFontSource(source);\n  var display = displayFromFontSource(source);\n  if (!uri || typeof uri !== 'string') {\n    throwInvalidSourceError(uri);\n  }\n  return {\n    uri: uri,\n    display: display\n  };\n}\nfunction throwInvalidSourceError(source) {\n  var type = typeof source;\n  if (type === 'object') type = JSON.stringify(source, null, 2);\n  throw new _expoModulesCore.CodedError(\"ERR_FONT_SOURCE\", \"Expected font asset of type `string | FontResource | Asset` instead got: \" + type);\n}\nfunction loadSingleFontAsync(name, input) {\n  return _regenerator.default.async(function loadSingleFontAsync$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        if (typeof input !== 'object' || typeof input.uri !== 'string' || input.downloadAsync) {\n          throwInvalidSourceError(input);\n        }\n        _context.next = 3;\n        return _regenerator.default.awrap(_ExpoFontLoader.default.loadAsync(name, input));\n      case 3:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getNativeFontName(name) {\n  return name;\n}","map":{"version":3,"sources":["../src/FontLoader.web.ts"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AAEA;AACA;AAGA,SAAS,iBAAiB,CAAC,KAAU,EAAA;EACnC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAO,KAAK,IAAI,IAAI;GACrB,MAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;IACpC,OAAO,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,OAAO,IAAI,IAAI;GAC5D,MAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;IACpC,OAAO,iBAAiB,CAAC,gBAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;EAClD;EACD,OAAO,IAAI;AACb;AAEA,SAAS,qBAAqB,CAAC,KAAU,EAAA;EACvC,OAAO,KAAK,CAAC,OAAO,IAAI,iBAAW,CAAC,IAAI;AAC1C;AAEM,SAAU,sBAAsB,CAAC,IAAY,EAAA;EACjD,OAAO,KAAK;AACd;AAEM,SAAU,iBAAiB,CAAC,MAAkB,EAAA;EAClD,IAAM,GAAG,GAAG,iBAAiB,CAAC,MAAM,CAAC;EACrC,IAAM,OAAO,GAAG,qBAAqB,CAAC,MAAM,CAAC;EAE7C,IAAI,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;IACnC,uBAAuB,CAAC,GAAG,CAAC;EAC7B;EAED,OAAO;IACL,GAAG,EAAE,GAAI;IACT,OAAO,EAAP;GACD;AACH;AAEA,SAAS,uBAAuB,CAAC,MAAW,EAAA;EAC1C,IAAI,IAAI,GAAW,OAAO,MAAM;EAChC,IAAI,IAAI,KAAK,QAAQ,EAAE,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;EAC7D,MAAM,IAAI,2BAAU,kGAE4D,IAAI,CACnF;AACH;AAEO,SAAe,mBAAmB,CACvC,IAAY,EACZ,KAA2B;EAAA;IAAA;MAAA;QAE3B,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,KAAK,CAAC,GAAG,KAAK,QAAQ,IAAK,KAAa,CAAC,aAAa,EAAE;UAC9F,uBAAuB,CAAC,KAAK,CAAC;;QAC/B;QAAA,kCAEK,uBAAc,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC;MAAA;MAAA;QAAA;IAAA;EAAA;AAAA;AAGvC,SAAU,iBAAiB,CAAC,IAAY,EAAA;EAC5C,OAAO,IAAI;AACb","sourcesContent":["import { Asset } from 'expo-asset';\nimport { CodedError } from 'expo-modules-core';\n\nimport ExpoFontLoader from './ExpoFontLoader';\nimport { FontDisplay } from './Font';\nimport { FontResource, FontSource } from './Font.types';\n\nfunction uriFromFontSource(asset: any): string | null {\n  if (typeof asset === 'string') {\n    return asset || null;\n  } else if (typeof asset === 'object') {\n    return asset.uri || asset.localUri || asset.default || null;\n  } else if (typeof asset === 'number') {\n    return uriFromFontSource(Asset.fromModule(asset));\n  }\n  return null;\n}\n\nfunction displayFromFontSource(asset: any): FontDisplay | undefined {\n  return asset.display || FontDisplay.AUTO;\n}\n\nexport function fontFamilyNeedsScoping(name: string): boolean {\n  return false;\n}\n\nexport function getAssetForSource(source: FontSource): Asset | FontResource {\n  const uri = uriFromFontSource(source);\n  const display = displayFromFontSource(source);\n\n  if (!uri || typeof uri !== 'string') {\n    throwInvalidSourceError(uri);\n  }\n\n  return {\n    uri: uri!,\n    display,\n  };\n}\n\nfunction throwInvalidSourceError(source: any): never {\n  let type: string = typeof source;\n  if (type === 'object') type = JSON.stringify(source, null, 2);\n  throw new CodedError(\n    `ERR_FONT_SOURCE`,\n    `Expected font asset of type \\`string | FontResource | Asset\\` instead got: ${type}`\n  );\n}\n\nexport async function loadSingleFontAsync(\n  name: string,\n  input: Asset | FontResource\n): Promise<void> {\n  if (typeof input !== 'object' || typeof input.uri !== 'string' || (input as any).downloadAsync) {\n    throwInvalidSourceError(input);\n  }\n\n  await ExpoFontLoader.loadAsync(name, input);\n}\n\nexport function getNativeFontName(name: string): string {\n  return name;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}