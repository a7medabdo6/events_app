{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MonthOfTheYear = exports.Frequency = exports.EventStatus = exports.EventAccessLevel = exports.EntityTypes = exports.DayOfTheWeek = exports.CalendarType = exports.CalendarAccessLevel = exports.Availability = exports.AttendeeType = exports.AttendeeStatus = exports.AttendeeRole = exports.AlarmMethod = void 0;\nObject.defineProperty(exports, \"PermissionStatus\", {\n  enumerable: true,\n  get: function get() {\n    return _expoModulesCore.PermissionStatus;\n  }\n});\nexports.SourceType = exports.ReminderStatus = void 0;\nexports.createAttendeeAsync = createAttendeeAsync;\nexports.createCalendarAsync = createCalendarAsync;\nexports.createEventAsync = createEventAsync;\nexports.createReminderAsync = createReminderAsync;\nexports.deleteAttendeeAsync = deleteAttendeeAsync;\nexports.deleteCalendarAsync = deleteCalendarAsync;\nexports.deleteEventAsync = deleteEventAsync;\nexports.deleteReminderAsync = deleteReminderAsync;\nexports.getAttendeesForEventAsync = getAttendeesForEventAsync;\nexports.getCalendarPermissionsAsync = getCalendarPermissionsAsync;\nexports.getCalendarsAsync = getCalendarsAsync;\nexports.getDefaultCalendarAsync = getDefaultCalendarAsync;\nexports.getEventAsync = getEventAsync;\nexports.getEventsAsync = getEventsAsync;\nexports.getReminderAsync = getReminderAsync;\nexports.getRemindersAsync = getRemindersAsync;\nexports.getRemindersPermissionsAsync = getRemindersPermissionsAsync;\nexports.getSourceAsync = getSourceAsync;\nexports.getSourcesAsync = getSourcesAsync;\nexports.isAvailableAsync = isAvailableAsync;\nexports.openEventInCalendar = openEventInCalendar;\nexports.requestCalendarPermissionsAsync = requestCalendarPermissionsAsync;\nexports.requestPermissionsAsync = requestPermissionsAsync;\nexports.requestRemindersPermissionsAsync = requestRemindersPermissionsAsync;\nexports.updateAttendeeAsync = updateAttendeeAsync;\nexports.updateCalendarAsync = updateCalendarAsync;\nexports.updateEventAsync = updateEventAsync;\nexports.updateReminderAsync = updateReminderAsync;\nexports.useRemindersPermissions = exports.useCalendarPermissions = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _extends4 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _expoModulesCore = require(\"expo-modules-core\");\nvar _reactNative = require(\"react-native\");\nvar _ExpoCalendar = _interopRequireDefault(require(\"./ExpoCalendar\"));\nvar _excluded = [\"id\"],\n  _excluded2 = [\"id\"];\nvar DayOfTheWeek;\nexports.DayOfTheWeek = DayOfTheWeek;\n(function (DayOfTheWeek) {\n  DayOfTheWeek[DayOfTheWeek[\"Sunday\"] = 1] = \"Sunday\";\n  DayOfTheWeek[DayOfTheWeek[\"Monday\"] = 2] = \"Monday\";\n  DayOfTheWeek[DayOfTheWeek[\"Tuesday\"] = 3] = \"Tuesday\";\n  DayOfTheWeek[DayOfTheWeek[\"Wednesday\"] = 4] = \"Wednesday\";\n  DayOfTheWeek[DayOfTheWeek[\"Thursday\"] = 5] = \"Thursday\";\n  DayOfTheWeek[DayOfTheWeek[\"Friday\"] = 6] = \"Friday\";\n  DayOfTheWeek[DayOfTheWeek[\"Saturday\"] = 7] = \"Saturday\";\n})(DayOfTheWeek || (exports.DayOfTheWeek = DayOfTheWeek = {}));\nvar MonthOfTheYear;\nexports.MonthOfTheYear = MonthOfTheYear;\n(function (MonthOfTheYear) {\n  MonthOfTheYear[MonthOfTheYear[\"January\"] = 1] = \"January\";\n  MonthOfTheYear[MonthOfTheYear[\"February\"] = 2] = \"February\";\n  MonthOfTheYear[MonthOfTheYear[\"March\"] = 3] = \"March\";\n  MonthOfTheYear[MonthOfTheYear[\"April\"] = 4] = \"April\";\n  MonthOfTheYear[MonthOfTheYear[\"May\"] = 5] = \"May\";\n  MonthOfTheYear[MonthOfTheYear[\"June\"] = 6] = \"June\";\n  MonthOfTheYear[MonthOfTheYear[\"July\"] = 7] = \"July\";\n  MonthOfTheYear[MonthOfTheYear[\"August\"] = 8] = \"August\";\n  MonthOfTheYear[MonthOfTheYear[\"September\"] = 9] = \"September\";\n  MonthOfTheYear[MonthOfTheYear[\"October\"] = 10] = \"October\";\n  MonthOfTheYear[MonthOfTheYear[\"November\"] = 11] = \"November\";\n  MonthOfTheYear[MonthOfTheYear[\"December\"] = 12] = \"December\";\n})(MonthOfTheYear || (exports.MonthOfTheYear = MonthOfTheYear = {}));\nfunction isAvailableAsync() {\n  return _regenerator.default.async(function isAvailableAsync$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        return _context.abrupt(\"return\", !!_ExpoCalendar.default.getCalendarsAsync);\n      case 1:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getCalendarsAsync(entityType) {\n  return _regenerator.default.async(function getCalendarsAsync$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        if (_ExpoCalendar.default.getCalendarsAsync) {\n          _context2.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getCalendarsAsync');\n      case 2:\n        if (entityType) {\n          _context2.next = 4;\n          break;\n        }\n        return _context2.abrupt(\"return\", _ExpoCalendar.default.getCalendarsAsync(null));\n      case 4:\n        return _context2.abrupt(\"return\", _ExpoCalendar.default.getCalendarsAsync(entityType));\n      case 5:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction createCalendarAsync() {\n  var details,\n    color,\n    newDetails,\n    _args3 = arguments;\n  return _regenerator.default.async(function createCalendarAsync$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        details = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n        if (_ExpoCalendar.default.saveCalendarAsync) {\n          _context3.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'createCalendarAsync');\n      case 3:\n        color = details.color ? (0, _reactNative.processColor)(details.color) : undefined;\n        newDetails = (0, _extends4.default)({}, details, {\n          id: undefined,\n          color: color\n        });\n        return _context3.abrupt(\"return\", _ExpoCalendar.default.saveCalendarAsync(newDetails));\n      case 6:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction updateCalendarAsync(id) {\n  var details,\n    color,\n    newDetails,\n    _args4 = arguments;\n  return _regenerator.default.async(function updateCalendarAsync$(_context4) {\n    while (1) switch (_context4.prev = _context4.next) {\n      case 0:\n        details = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n        if (_ExpoCalendar.default.saveCalendarAsync) {\n          _context4.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'updateCalendarAsync');\n      case 3:\n        if (id) {\n          _context4.next = 5;\n          break;\n        }\n        throw new Error('updateCalendarAsync must be called with an id (string) of the target calendar');\n      case 5:\n        color = details.color ? (0, _reactNative.processColor)(details.color) : undefined;\n        if (_reactNative.Platform.OS === 'android') {\n          if (details.hasOwnProperty('source') || details.hasOwnProperty('color') || details.hasOwnProperty('allowsModifications') || details.hasOwnProperty('allowedAvailabilities') || details.hasOwnProperty('isPrimary') || details.hasOwnProperty('ownerAccount') || details.hasOwnProperty('timeZone') || details.hasOwnProperty('allowedReminders') || details.hasOwnProperty('allowedAttendeeTypes') || details.hasOwnProperty('accessLevel')) {}\n        } else {\n          if (details.hasOwnProperty('source') || details.hasOwnProperty('type') || details.hasOwnProperty('entityType') || details.hasOwnProperty('allowsModifications') || details.hasOwnProperty('allowedAvailabilities')) {}\n        }\n        newDetails = (0, _extends4.default)({}, details, {\n          id: id,\n          color: color\n        });\n        return _context4.abrupt(\"return\", _ExpoCalendar.default.saveCalendarAsync(newDetails));\n      case 9:\n      case \"end\":\n        return _context4.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction deleteCalendarAsync(id) {\n  return _regenerator.default.async(function deleteCalendarAsync$(_context5) {\n    while (1) switch (_context5.prev = _context5.next) {\n      case 0:\n        if (_ExpoCalendar.default.deleteCalendarAsync) {\n          _context5.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'deleteCalendarAsync');\n      case 2:\n        if (id) {\n          _context5.next = 4;\n          break;\n        }\n        throw new Error('deleteCalendarAsync must be called with an id (string) of the target calendar');\n      case 4:\n        return _context5.abrupt(\"return\", _ExpoCalendar.default.deleteCalendarAsync(id));\n      case 5:\n      case \"end\":\n        return _context5.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getEventsAsync(calendarIds, startDate, endDate) {\n  return _regenerator.default.async(function getEventsAsync$(_context6) {\n    while (1) switch (_context6.prev = _context6.next) {\n      case 0:\n        if (_ExpoCalendar.default.getEventsAsync) {\n          _context6.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getEventsAsync');\n      case 2:\n        if (startDate) {\n          _context6.next = 4;\n          break;\n        }\n        throw new Error('getEventsAsync must be called with a startDate (date) to search for events');\n      case 4:\n        if (endDate) {\n          _context6.next = 6;\n          break;\n        }\n        throw new Error('getEventsAsync must be called with an endDate (date) to search for events');\n      case 6:\n        if (!(!calendarIds || !calendarIds.length)) {\n          _context6.next = 8;\n          break;\n        }\n        throw new Error('getEventsAsync must be called with a non-empty array of calendarIds to search');\n      case 8:\n        return _context6.abrupt(\"return\", _ExpoCalendar.default.getEventsAsync(stringifyIfDate(startDate), stringifyIfDate(endDate), calendarIds));\n      case 9:\n      case \"end\":\n        return _context6.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getEventAsync(id) {\n  var recurringEventOptions,\n    _args7 = arguments;\n  return _regenerator.default.async(function getEventAsync$(_context7) {\n    while (1) switch (_context7.prev = _context7.next) {\n      case 0:\n        recurringEventOptions = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n        if (_ExpoCalendar.default.getEventByIdAsync) {\n          _context7.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getEventAsync');\n      case 3:\n        if (id) {\n          _context7.next = 5;\n          break;\n        }\n        throw new Error('getEventAsync must be called with an id (string) of the target event');\n      case 5:\n        if (!(_reactNative.Platform.OS === 'ios')) {\n          _context7.next = 9;\n          break;\n        }\n        return _context7.abrupt(\"return\", _ExpoCalendar.default.getEventByIdAsync(id, recurringEventOptions.instanceStartDate));\n      case 9:\n        return _context7.abrupt(\"return\", _ExpoCalendar.default.getEventByIdAsync(id));\n      case 10:\n      case \"end\":\n        return _context7.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction createEventAsync(calendarId) {\n  var eventData,\n    id,\n    details,\n    newDetails,\n    _args8 = arguments;\n  return _regenerator.default.async(function createEventAsync$(_context8) {\n    while (1) switch (_context8.prev = _context8.next) {\n      case 0:\n        eventData = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n        if (_ExpoCalendar.default.saveEventAsync) {\n          _context8.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'createEventAsync');\n      case 3:\n        if (calendarId) {\n          _context8.next = 5;\n          break;\n        }\n        throw new Error('createEventAsync must be called with an id (string) of the target calendar');\n      case 5:\n        id = eventData.id, details = (0, _objectWithoutProperties2.default)(eventData, _excluded);\n        if (!(_reactNative.Platform.OS === 'android')) {\n          _context8.next = 11;\n          break;\n        }\n        if (details.startDate) {\n          _context8.next = 9;\n          break;\n        }\n        throw new Error('createEventAsync requires a startDate (Date)');\n      case 9:\n        if (details.endDate) {\n          _context8.next = 11;\n          break;\n        }\n        throw new Error('createEventAsync requires an endDate (Date)');\n      case 11:\n        newDetails = (0, _extends4.default)({}, details, {\n          calendarId: calendarId\n        });\n        return _context8.abrupt(\"return\", _ExpoCalendar.default.saveEventAsync(stringifyDateValues(newDetails), {}));\n      case 13:\n      case \"end\":\n        return _context8.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction updateEventAsync(id) {\n  var details,\n    recurringEventOptions,\n    _recurringEventOption,\n    futureEvents,\n    instanceStartDate,\n    newDetails,\n    _args9 = arguments;\n  return _regenerator.default.async(function updateEventAsync$(_context9) {\n    while (1) switch (_context9.prev = _context9.next) {\n      case 0:\n        details = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n        recurringEventOptions = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};\n        if (_ExpoCalendar.default.saveEventAsync) {\n          _context9.next = 4;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'updateEventAsync');\n      case 4:\n        if (id) {\n          _context9.next = 6;\n          break;\n        }\n        throw new Error('updateEventAsync must be called with an id (string) of the target event');\n      case 6:\n        if (_reactNative.Platform.OS === 'ios') {\n          if (details.hasOwnProperty('creationDate') || details.hasOwnProperty('lastModifiedDate') || details.hasOwnProperty('originalStartDate') || details.hasOwnProperty('isDetached') || details.hasOwnProperty('status') || details.hasOwnProperty('organizer')) {}\n        }\n        _recurringEventOption = recurringEventOptions.futureEvents, futureEvents = _recurringEventOption === void 0 ? false : _recurringEventOption, instanceStartDate = recurringEventOptions.instanceStartDate;\n        newDetails = (0, _extends4.default)({}, details, {\n          id: id,\n          instanceStartDate: instanceStartDate\n        });\n        return _context9.abrupt(\"return\", _ExpoCalendar.default.saveEventAsync(stringifyDateValues(newDetails), {\n          futureEvents: futureEvents\n        }));\n      case 10:\n      case \"end\":\n        return _context9.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction deleteEventAsync(id) {\n  var recurringEventOptions,\n    _recurringEventOption2,\n    futureEvents,\n    instanceStartDate,\n    _args10 = arguments;\n  return _regenerator.default.async(function deleteEventAsync$(_context10) {\n    while (1) switch (_context10.prev = _context10.next) {\n      case 0:\n        recurringEventOptions = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};\n        if (_ExpoCalendar.default.deleteEventAsync) {\n          _context10.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'deleteEventAsync');\n      case 3:\n        if (id) {\n          _context10.next = 5;\n          break;\n        }\n        throw new Error('deleteEventAsync must be called with an id (string) of the target event');\n      case 5:\n        _recurringEventOption2 = recurringEventOptions.futureEvents, futureEvents = _recurringEventOption2 === void 0 ? false : _recurringEventOption2, instanceStartDate = recurringEventOptions.instanceStartDate;\n        return _context10.abrupt(\"return\", _ExpoCalendar.default.deleteEventAsync({\n          id: id,\n          instanceStartDate: instanceStartDate\n        }, {\n          futureEvents: futureEvents\n        }));\n      case 7:\n      case \"end\":\n        return _context10.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getAttendeesForEventAsync(id) {\n  var recurringEventOptions,\n    instanceStartDate,\n    params,\n    _args11 = arguments;\n  return _regenerator.default.async(function getAttendeesForEventAsync$(_context11) {\n    while (1) switch (_context11.prev = _context11.next) {\n      case 0:\n        recurringEventOptions = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};\n        if (_ExpoCalendar.default.getAttendeesForEventAsync) {\n          _context11.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getAttendeesForEventAsync');\n      case 3:\n        if (id) {\n          _context11.next = 5;\n          break;\n        }\n        throw new Error('getAttendeesForEventAsync must be called with an id (string) of the target event');\n      case 5:\n        instanceStartDate = recurringEventOptions.instanceStartDate;\n        params = _reactNative.Platform.OS === 'ios' ? {\n          id: id,\n          instanceStartDate: instanceStartDate\n        } : id;\n        return _context11.abrupt(\"return\", _ExpoCalendar.default.getAttendeesForEventAsync(params));\n      case 8:\n      case \"end\":\n        return _context11.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction createAttendeeAsync(eventId) {\n  var details,\n    newDetails,\n    _args12 = arguments;\n  return _regenerator.default.async(function createAttendeeAsync$(_context12) {\n    while (1) switch (_context12.prev = _context12.next) {\n      case 0:\n        details = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};\n        if (_ExpoCalendar.default.saveAttendeeForEventAsync) {\n          _context12.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'createAttendeeAsync');\n      case 3:\n        if (eventId) {\n          _context12.next = 5;\n          break;\n        }\n        throw new Error('createAttendeeAsync must be called with an id (string) of the target event');\n      case 5:\n        if (details.email) {\n          _context12.next = 7;\n          break;\n        }\n        throw new Error('createAttendeeAsync requires an email (string)');\n      case 7:\n        if (details.role) {\n          _context12.next = 9;\n          break;\n        }\n        throw new Error('createAttendeeAsync requires a role (string)');\n      case 9:\n        if (details.type) {\n          _context12.next = 11;\n          break;\n        }\n        throw new Error('createAttendeeAsync requires a type (string)');\n      case 11:\n        if (details.status) {\n          _context12.next = 13;\n          break;\n        }\n        throw new Error('createAttendeeAsync requires a status (string)');\n      case 13:\n        newDetails = (0, _extends4.default)({}, details, {\n          id: undefined\n        });\n        return _context12.abrupt(\"return\", _ExpoCalendar.default.saveAttendeeForEventAsync(newDetails, eventId));\n      case 15:\n      case \"end\":\n        return _context12.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction updateAttendeeAsync(id) {\n  var details,\n    newDetails,\n    _args13 = arguments;\n  return _regenerator.default.async(function updateAttendeeAsync$(_context13) {\n    while (1) switch (_context13.prev = _context13.next) {\n      case 0:\n        details = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};\n        if (_ExpoCalendar.default.saveAttendeeForEventAsync) {\n          _context13.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'updateAttendeeAsync');\n      case 3:\n        if (id) {\n          _context13.next = 5;\n          break;\n        }\n        throw new Error('updateAttendeeAsync must be called with an id (string) of the target event');\n      case 5:\n        newDetails = (0, _extends4.default)({}, details, {\n          id: id\n        });\n        return _context13.abrupt(\"return\", _ExpoCalendar.default.saveAttendeeForEventAsync(newDetails, null));\n      case 7:\n      case \"end\":\n        return _context13.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getDefaultCalendarAsync() {\n  return _regenerator.default.async(function getDefaultCalendarAsync$(_context14) {\n    while (1) switch (_context14.prev = _context14.next) {\n      case 0:\n        if (_ExpoCalendar.default.getDefaultCalendarAsync) {\n          _context14.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getDefaultCalendarAsync');\n      case 2:\n        return _context14.abrupt(\"return\", _ExpoCalendar.default.getDefaultCalendarAsync());\n      case 3:\n      case \"end\":\n        return _context14.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction deleteAttendeeAsync(id) {\n  return _regenerator.default.async(function deleteAttendeeAsync$(_context15) {\n    while (1) switch (_context15.prev = _context15.next) {\n      case 0:\n        if (_ExpoCalendar.default.deleteAttendeeAsync) {\n          _context15.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'deleteAttendeeAsync');\n      case 2:\n        if (id) {\n          _context15.next = 4;\n          break;\n        }\n        throw new Error('deleteAttendeeAsync must be called with an id (string) of the target event');\n      case 4:\n        return _context15.abrupt(\"return\", _ExpoCalendar.default.deleteAttendeeAsync(id));\n      case 5:\n      case \"end\":\n        return _context15.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getRemindersAsync(calendarIds, status, startDate, endDate) {\n  return _regenerator.default.async(function getRemindersAsync$(_context16) {\n    while (1) switch (_context16.prev = _context16.next) {\n      case 0:\n        if (_ExpoCalendar.default.getRemindersAsync) {\n          _context16.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getRemindersAsync');\n      case 2:\n        if (!(status && !startDate)) {\n          _context16.next = 4;\n          break;\n        }\n        throw new Error('getRemindersAsync must be called with a startDate (date) to search for reminders');\n      case 4:\n        if (!(status && !endDate)) {\n          _context16.next = 6;\n          break;\n        }\n        throw new Error('getRemindersAsync must be called with an endDate (date) to search for reminders');\n      case 6:\n        if (!(!calendarIds || !calendarIds.length)) {\n          _context16.next = 8;\n          break;\n        }\n        throw new Error('getRemindersAsync must be called with a non-empty array of calendarIds to search');\n      case 8:\n        return _context16.abrupt(\"return\", _ExpoCalendar.default.getRemindersAsync(stringifyIfDate(startDate) || null, stringifyIfDate(endDate) || null, calendarIds, status || null));\n      case 9:\n      case \"end\":\n        return _context16.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getReminderAsync(id) {\n  return _regenerator.default.async(function getReminderAsync$(_context17) {\n    while (1) switch (_context17.prev = _context17.next) {\n      case 0:\n        if (_ExpoCalendar.default.getReminderByIdAsync) {\n          _context17.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getReminderAsync');\n      case 2:\n        if (id) {\n          _context17.next = 4;\n          break;\n        }\n        throw new Error('getReminderAsync must be called with an id (string) of the target reminder');\n      case 4:\n        return _context17.abrupt(\"return\", _ExpoCalendar.default.getReminderByIdAsync(id));\n      case 5:\n      case \"end\":\n        return _context17.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction createReminderAsync(calendarId) {\n  var reminder,\n    id,\n    details,\n    newDetails,\n    _args18 = arguments;\n  return _regenerator.default.async(function createReminderAsync$(_context18) {\n    while (1) switch (_context18.prev = _context18.next) {\n      case 0:\n        reminder = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : {};\n        if (_ExpoCalendar.default.saveReminderAsync) {\n          _context18.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'createReminderAsync');\n      case 3:\n        id = reminder.id, details = (0, _objectWithoutProperties2.default)(reminder, _excluded2);\n        newDetails = (0, _extends4.default)({}, details, {\n          calendarId: calendarId === null ? undefined : calendarId\n        });\n        return _context18.abrupt(\"return\", _ExpoCalendar.default.saveReminderAsync(stringifyDateValues(newDetails)));\n      case 6:\n      case \"end\":\n        return _context18.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction updateReminderAsync(id) {\n  var details,\n    newDetails,\n    _args19 = arguments;\n  return _regenerator.default.async(function updateReminderAsync$(_context19) {\n    while (1) switch (_context19.prev = _context19.next) {\n      case 0:\n        details = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {};\n        if (_ExpoCalendar.default.saveReminderAsync) {\n          _context19.next = 3;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'updateReminderAsync');\n      case 3:\n        if (id) {\n          _context19.next = 5;\n          break;\n        }\n        throw new Error('updateReminderAsync must be called with an id (string) of the target reminder');\n      case 5:\n        if (details.hasOwnProperty('creationDate') || details.hasOwnProperty('lastModifiedDate')) {}\n        newDetails = (0, _extends4.default)({}, details, {\n          id: id\n        });\n        return _context19.abrupt(\"return\", _ExpoCalendar.default.saveReminderAsync(stringifyDateValues(newDetails)));\n      case 8:\n      case \"end\":\n        return _context19.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction deleteReminderAsync(id) {\n  return _regenerator.default.async(function deleteReminderAsync$(_context20) {\n    while (1) switch (_context20.prev = _context20.next) {\n      case 0:\n        if (_ExpoCalendar.default.deleteReminderAsync) {\n          _context20.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'deleteReminderAsync');\n      case 2:\n        if (id) {\n          _context20.next = 4;\n          break;\n        }\n        throw new Error('deleteReminderAsync must be called with an id (string) of the target reminder');\n      case 4:\n        return _context20.abrupt(\"return\", _ExpoCalendar.default.deleteReminderAsync(id));\n      case 5:\n      case \"end\":\n        return _context20.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getSourcesAsync() {\n  return _regenerator.default.async(function getSourcesAsync$(_context21) {\n    while (1) switch (_context21.prev = _context21.next) {\n      case 0:\n        if (_ExpoCalendar.default.getSourcesAsync) {\n          _context21.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getSourcesAsync');\n      case 2:\n        return _context21.abrupt(\"return\", _ExpoCalendar.default.getSourcesAsync());\n      case 3:\n      case \"end\":\n        return _context21.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getSourceAsync(id) {\n  return _regenerator.default.async(function getSourceAsync$(_context22) {\n    while (1) switch (_context22.prev = _context22.next) {\n      case 0:\n        if (_ExpoCalendar.default.getSourceByIdAsync) {\n          _context22.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getSourceAsync');\n      case 2:\n        if (id) {\n          _context22.next = 4;\n          break;\n        }\n        throw new Error('getSourceAsync must be called with an id (string) of the target source');\n      case 4:\n        return _context22.abrupt(\"return\", _ExpoCalendar.default.getSourceByIdAsync(id));\n      case 5:\n      case \"end\":\n        return _context22.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction openEventInCalendar(id) {\n  if (!_ExpoCalendar.default.openEventInCalendar) {\n    return;\n  }\n  if (!id) {\n    throw new Error('openEventInCalendar must be called with an id (string) of the target event');\n  }\n  return _ExpoCalendar.default.openEventInCalendar(parseInt(id, 10));\n}\nfunction requestPermissionsAsync() {\n  return _regenerator.default.async(function requestPermissionsAsync$(_context23) {\n    while (1) switch (_context23.prev = _context23.next) {\n      case 0:\n        return _context23.abrupt(\"return\", requestCalendarPermissionsAsync());\n      case 1:\n      case \"end\":\n        return _context23.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getCalendarPermissionsAsync() {\n  return _regenerator.default.async(function getCalendarPermissionsAsync$(_context24) {\n    while (1) switch (_context24.prev = _context24.next) {\n      case 0:\n        if (_ExpoCalendar.default.getCalendarPermissionsAsync) {\n          _context24.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getCalendarPermissionsAsync');\n      case 2:\n        return _context24.abrupt(\"return\", _ExpoCalendar.default.getCalendarPermissionsAsync());\n      case 3:\n      case \"end\":\n        return _context24.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getRemindersPermissionsAsync() {\n  return _regenerator.default.async(function getRemindersPermissionsAsync$(_context25) {\n    while (1) switch (_context25.prev = _context25.next) {\n      case 0:\n        if (_ExpoCalendar.default.getRemindersPermissionsAsync) {\n          _context25.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'getRemindersPermissionsAsync');\n      case 2:\n        return _context25.abrupt(\"return\", _ExpoCalendar.default.getRemindersPermissionsAsync());\n      case 3:\n      case \"end\":\n        return _context25.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction requestCalendarPermissionsAsync() {\n  return _regenerator.default.async(function requestCalendarPermissionsAsync$(_context26) {\n    while (1) switch (_context26.prev = _context26.next) {\n      case 0:\n        if (_ExpoCalendar.default.requestCalendarPermissionsAsync) {\n          _context26.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'requestCalendarPermissionsAsync');\n      case 2:\n        _context26.next = 4;\n        return _regenerator.default.awrap(_ExpoCalendar.default.requestCalendarPermissionsAsync());\n      case 4:\n        return _context26.abrupt(\"return\", _context26.sent);\n      case 5:\n      case \"end\":\n        return _context26.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction requestRemindersPermissionsAsync() {\n  return _regenerator.default.async(function requestRemindersPermissionsAsync$(_context27) {\n    while (1) switch (_context27.prev = _context27.next) {\n      case 0:\n        if (_ExpoCalendar.default.requestRemindersPermissionsAsync) {\n          _context27.next = 2;\n          break;\n        }\n        throw new _expoModulesCore.UnavailabilityError('Calendar', 'requestRemindersPermissionsAsync');\n      case 2:\n        _context27.next = 4;\n        return _regenerator.default.awrap(_ExpoCalendar.default.requestRemindersPermissionsAsync());\n      case 4:\n        return _context27.abrupt(\"return\", _context27.sent);\n      case 5:\n      case \"end\":\n        return _context27.stop();\n    }\n  }, null, null, null, Promise);\n}\nvar useCalendarPermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: getCalendarPermissionsAsync,\n  requestMethod: requestCalendarPermissionsAsync\n});\nexports.useCalendarPermissions = useCalendarPermissions;\nvar useRemindersPermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: getRemindersPermissionsAsync,\n  requestMethod: requestRemindersPermissionsAsync\n});\nexports.useRemindersPermissions = useRemindersPermissions;\nvar EntityTypes = {\n  EVENT: 'event',\n  REMINDER: 'reminder'\n};\nexports.EntityTypes = EntityTypes;\nvar Frequency = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly'\n};\nexports.Frequency = Frequency;\nvar Availability = {\n  NOT_SUPPORTED: 'notSupported',\n  BUSY: 'busy',\n  FREE: 'free',\n  TENTATIVE: 'tentative',\n  UNAVAILABLE: 'unavailable'\n};\nexports.Availability = Availability;\nvar CalendarType = {\n  LOCAL: 'local',\n  CALDAV: 'caldav',\n  EXCHANGE: 'exchange',\n  SUBSCRIBED: 'subscribed',\n  BIRTHDAYS: 'birthdays',\n  UNKNOWN: 'unknown'\n};\nexports.CalendarType = CalendarType;\nvar EventStatus = {\n  NONE: 'none',\n  CONFIRMED: 'confirmed',\n  TENTATIVE: 'tentative',\n  CANCELED: 'canceled'\n};\nexports.EventStatus = EventStatus;\nvar SourceType = {\n  LOCAL: 'local',\n  EXCHANGE: 'exchange',\n  CALDAV: 'caldav',\n  MOBILEME: 'mobileme',\n  SUBSCRIBED: 'subscribed',\n  BIRTHDAYS: 'birthdays'\n};\nexports.SourceType = SourceType;\nvar AttendeeRole = {\n  UNKNOWN: 'unknown',\n  REQUIRED: 'required',\n  OPTIONAL: 'optional',\n  CHAIR: 'chair',\n  NON_PARTICIPANT: 'nonParticipant',\n  ATTENDEE: 'attendee',\n  ORGANIZER: 'organizer',\n  PERFORMER: 'performer',\n  SPEAKER: 'speaker',\n  NONE: 'none'\n};\nexports.AttendeeRole = AttendeeRole;\nvar AttendeeStatus = {\n  UNKNOWN: 'unknown',\n  PENDING: 'pending',\n  ACCEPTED: 'accepted',\n  DECLINED: 'declined',\n  TENTATIVE: 'tentative',\n  DELEGATED: 'delegated',\n  COMPLETED: 'completed',\n  IN_PROCESS: 'inProcess',\n  INVITED: 'invited',\n  NONE: 'none'\n};\nexports.AttendeeStatus = AttendeeStatus;\nvar AttendeeType = {\n  UNKNOWN: 'unknown',\n  PERSON: 'person',\n  ROOM: 'room',\n  GROUP: 'group',\n  RESOURCE: 'resource',\n  OPTIONAL: 'optional',\n  REQUIRED: 'required',\n  NONE: 'none'\n};\nexports.AttendeeType = AttendeeType;\nvar AlarmMethod = {\n  ALARM: 'alarm',\n  ALERT: 'alert',\n  EMAIL: 'email',\n  SMS: 'sms',\n  DEFAULT: 'default'\n};\nexports.AlarmMethod = AlarmMethod;\nvar EventAccessLevel = {\n  CONFIDENTIAL: 'confidential',\n  PRIVATE: 'private',\n  PUBLIC: 'public',\n  DEFAULT: 'default'\n};\nexports.EventAccessLevel = EventAccessLevel;\nvar CalendarAccessLevel = {\n  CONTRIBUTOR: 'contributor',\n  EDITOR: 'editor',\n  FREEBUSY: 'freebusy',\n  OVERRIDE: 'override',\n  OWNER: 'owner',\n  READ: 'read',\n  RESPOND: 'respond',\n  ROOT: 'root',\n  NONE: 'none'\n};\nexports.CalendarAccessLevel = CalendarAccessLevel;\nvar ReminderStatus = {\n  COMPLETED: 'completed',\n  INCOMPLETE: 'incomplete'\n};\nexports.ReminderStatus = ReminderStatus;\nfunction stringifyIfDate(date) {\n  return date instanceof Date ? date.toISOString() : date;\n}\nfunction stringifyDateValues(obj) {\n  return Object.keys(obj).reduce(function (acc, key) {\n    var value = obj[key];\n    if (value != null && typeof value === 'object' && !(value instanceof Date)) {\n      if (Array.isArray(value)) {\n        return (0, _extends4.default)({}, acc, (0, _defineProperty2.default)({}, key, value.map(stringifyDateValues)));\n      }\n      return (0, _extends4.default)({}, acc, (0, _defineProperty2.default)({}, key, stringifyDateValues(value)));\n    }\n    acc[key] = stringifyIfDate(value);\n    return acc;\n  }, {});\n}","map":{"version":3,"sources":["../src/Calendar.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  UnavailabilityError,\n} from 'expo-modules-core';\nimport { Platform, processColor } from 'react-native';\n\nimport ExpoCalendar from './ExpoCalendar';\n\n// @needsAudit\n/**\n * @platform ios\n */\nexport type RecurringEventOptions = {\n  /**\n   * Whether or not future events in the recurring series should also be updated. If `true`, will\n   * apply the given changes to the recurring instance specified by `instanceStartDate` and all\n   * future events in the series. If `false`, will only apply the given changes to the instance\n   * specified by `instanceStartDate`.\n   */\n  futureEvents?: boolean;\n  /**\n   * Date object representing the start time of the desired instance, if looking for a single instance\n   * of a recurring event. If this is not provided and **id** represents a recurring event, the first\n   * instance of that event will be returned by default.\n   */\n  instanceStartDate?: string | Date;\n};\n\n// @needsAudit\n/**\n * A calendar record upon which events (or, on iOS, reminders) can be stored. Settings here apply to\n * the calendar as a whole and how its events are displayed in the OS calendar app.\n */\nexport type Calendar = {\n  /**\n   * Internal ID that represents this calendar on the device.\n   */\n  id: string;\n  /**\n   * Visible name of the calendar.\n   */\n  title: string;\n  /**\n   * ID of the source to be used for the calendar. Likely the same as the source for any other\n   * locally stored calendars.\n   * @platform ios\n   */\n  sourceId?: string;\n  /**\n   * Object representing the source to be used for the calendar.\n   */\n  source: Source;\n  /**\n   * Type of calendar this object represents.\n   * Possible values: [`CalendarType`](#calendarcalendartype).\n   * @platform ios\n   */\n  type?: string;\n  /**\n   * Color used to display this calendar's events.\n   */\n  color: string;\n  /**\n   * Whether the calendar is used in the Calendar or Reminders OS app.\n   * Possible values: [`EntityTypes`](#calendarentitytypes).\n   * @platform ios\n   */\n  entityType?: string;\n  /**\n   * Boolean value that determines whether this calendar can be modified.\n   */\n  allowsModifications: boolean;\n  /**\n   * Availability types that this calendar supports.\n   * Possible values: Array of [`Availability`](#calendaravailability).\n   */\n  allowedAvailabilities: string[];\n  /**\n   * Boolean value indicating whether this is the device's primary calendar.\n   * @platform android\n   */\n  isPrimary?: boolean;\n  /**\n   * Internal system name of the calendar.\n   * @platform android\n   */\n  name?: string | null;\n  /**\n   * Name for the account that owns this calendar.\n   * @platform android\n   */\n  ownerAccount?: string;\n  /**\n   * Time zone for the calendar.\n   * @platform android\n   */\n  timeZone?: string;\n  /**\n   * Alarm methods that this calendar supports.\n   * Possible values: Array of [`AlarmMethod`](#calendaralarmmethod).\n   * @platform android\n   */\n  allowedReminders?: string[];\n  /**\n   * Attendee types that this calendar supports.\n   * Possible values: Array of [`AttendeeType`](#calendarattendeetype).\n   * @platform android\n   */\n  allowedAttendeeTypes?: string[];\n  /**\n   * Indicates whether the OS displays events on this calendar.\n   * @platform android\n   */\n  isVisible?: boolean;\n  /**\n   * Indicates whether this calendar is synced and its events stored on the device.\n   * Unexpected behavior may occur if this is not set to `true`.\n   * @platform android\n   */\n  isSynced?: boolean;\n  /**\n   * Level of access that the user has for the calendar.\n   * Possible values: [`CalendarAccessLevel`](#calendarcalendaraccesslevel).\n   * @platform android\n   */\n  accessLevel?: string;\n};\n\n// @needsAudit\n/**\n * A source account that owns a particular calendar. Expo apps will typically not need to interact with `Source` objects.\n */\nexport type Source = {\n  /**\n   * Internal ID that represents this source on the device.\n   * @platform ios\n   */\n  id?: string;\n  /**\n   * Type of the account that owns this calendar and was used to sync it to the device.\n   * If `isLocalAccount` is falsy then this must be defined, and must match an account on the device\n   * along with `name`, or the OS will delete the calendar.\n   * On iOS, one of [`SourceType`](#calendarsourcetype)s.\n   */\n  type: string;\n  /**\n   * Name for the account that owns this calendar and was used to sync the calendar to the device.\n   */\n  name: string;\n  /**\n   * Whether this source is the local phone account. Must be `true` if `type` is `undefined`.\n   * @platform android\n   */\n  isLocalAccount?: boolean;\n};\n\n// @needsAudit\n/**\n * An event record, or a single instance of a recurring event. On iOS, used in the Calendar app.\n */\nexport type Event = {\n  /**\n   * Internal ID that represents this event on the device.\n   */\n  id: string;\n  /**\n   * ID of the calendar that contains this event.\n   */\n  calendarId: string;\n  /**\n   * Visible name of the event.\n   */\n  title: string;\n  /**\n   * Location field of the event.\n   */\n  location: string;\n  /**\n   * Date when the event record was created.\n   * @platform ios\n   */\n  creationDate?: string | Date;\n  /**\n   * Date when the event record was last modified.\n   * @platform ios\n   */\n  lastModifiedDate?: string | Date;\n  /**\n   * Time zone the event is scheduled in.\n   */\n  timeZone: string;\n  /**\n   * Time zone for the event end time.\n   * @platform android\n   */\n  endTimeZone?: string;\n  /**\n   * URL for the event.\n   * @platform ios\n   */\n  url?: string;\n  /**\n   * Description or notes saved with the event.\n   */\n  notes: string;\n  /**\n   * Array of Alarm objects which control automated reminders to the user.\n   */\n  alarms: Alarm[];\n  /**\n   * Object representing rules for recurring or repeating events. Set to `null` for one-time events.\n   */\n  recurrenceRule: RecurrenceRule;\n  /**\n   * Date object or string representing the time when the event starts.\n   */\n  startDate: string | Date;\n  /**\n   * Date object or string representing the time when the event ends.\n   */\n  endDate: string | Date;\n  /**\n   * For recurring events, the start date for the first (original) instance of the event.\n   * @platform ios\n   */\n  originalStartDate?: string | Date;\n  /**\n   * Boolean value indicating whether or not the event is a detached (modified) instance of a recurring event.\n   * @platform ios\n   */\n  isDetached?: boolean;\n  /**\n   * Whether the event is displayed as an all-day event on the calendar\n   */\n  allDay: boolean;\n  /**\n   * The availability setting for the event.\n   * Possible values: [`Availability`](#calendaravailability).\n   */\n  availability: string;\n  /**\n   * Status of the event.\n   * Possible values: [`EventStatus`](#calendareventstatus).\n   */\n  status: string;\n  /**\n   * Organizer of the event.\n   * @platform ios\n   */\n  organizer?: string;\n  /**\n   * Email address of the organizer of the event.\n   * @platform android\n   */\n  organizerEmail?: string;\n  /**\n   * User's access level for the event.\n   * Possible values: [`EventAccessLevel`](#calendareventaccesslevel).\n   * @platform android\n   */\n  accessLevel?: string;\n  /**\n   * Whether invited guests can modify the details of the event.\n   * @platform android\n   */\n  guestsCanModify?: boolean;\n  /**\n   * Whether invited guests can invite other guests.\n   * @platform android\n   */\n  guestsCanInviteOthers?: boolean;\n  /**\n   * Whether invited guests can see other guests.\n   * @platform android\n   */\n  guestsCanSeeGuests?: boolean;\n  /**\n   * For detached (modified) instances of recurring events, the ID of the original recurring event.\n   * @platform android\n   */\n  originalId?: string;\n  /**\n   * For instances of recurring events, volatile ID representing this instance. Not guaranteed to\n   * always refer to the same instance.\n   * @platform android\n   */\n  instanceId?: string;\n};\n\n// @needsAudit\n/**\n * A reminder record, used in the iOS Reminders app. No direct analog on Android.\n * @platform ios\n */\nexport type Reminder = {\n  /**\n   * Internal ID that represents this reminder on the device.\n   */\n  id?: string;\n  /**\n   * ID of the calendar that contains this reminder.\n   */\n  calendarId?: string;\n  /**\n   * Visible name of the reminder.\n   */\n  title?: string;\n  /**\n   * Location field of the reminder\n   */\n  location?: string;\n  /**\n   * Date when the reminder record was created.\n   */\n  creationDate?: string | Date;\n  /**\n   * Date when the reminder record was last modified.\n   */\n  lastModifiedDate?: string | Date;\n  /**\n   * Time zone the reminder is scheduled in.\n   */\n  timeZone?: string;\n  /**\n   * URL for the reminder.\n   */\n  url?: string;\n  /**\n   * Description or notes saved with the reminder.\n   */\n  notes?: string;\n  /**\n   * Array of Alarm objects which control automated alarms to the user about the task.\n   */\n  alarms?: Alarm[];\n  /**\n   * Object representing rules for recurring or repeated reminders. Null for one-time tasks.\n   */\n  recurrenceRule?: RecurrenceRule;\n  /**\n   * Date object or string representing the start date of the reminder task.\n   */\n  startDate?: string | Date;\n  /**\n   * Date object or string representing the time when the reminder task is due.\n   */\n  dueDate?: string | Date;\n  /**\n   * Indicates whether or not the task has been completed.\n   */\n  completed?: boolean;\n  /**\n   * Date object or string representing the date of completion, if `completed` is `true`.\n   * Setting this property of a nonnull `Date` will automatically set the reminder's `completed` value to `true`.\n   */\n  completionDate?: string | Date;\n};\n\n// @needsAudit\n/**\n * A person or entity that is associated with an event by being invited or fulfilling some other role.\n */\nexport type Attendee = {\n  /**\n   * Internal ID that represents this attendee on the device.\n   * @platform android\n   */\n  id?: string;\n  /**\n   * Indicates whether or not this attendee is the current OS user.\n   * @platform ios\n   */\n  isCurrentUser?: boolean;\n  /**\n   * Displayed name of the attendee.\n   */\n  name: string;\n  /**\n   * Role of the attendee at the event.\n   * Possible values: [`AttendeeRole`](#calendarattendeerole).\n   */\n  role: string;\n  /**\n   * Status of the attendee in relation to the event.\n   * Possible values: [`AttendeeStatus`](#calendarattendeestatus).\n   */\n  status: string;\n  /**\n   * Type of the attendee.\n   * Possible values: [`AttendeeType`](#calendarattendeetype).\n   */\n  type: string;\n  /**\n   * URL for the attendee.\n   * @platform ios\n   */\n  url?: string;\n  /**\n   * Email address of the attendee.\n   * @platform android\n   */\n  email?: string;\n};\n\n// @needsAudit\n/**\n * A method for having the OS automatically remind the user about an calendar item.\n */\nexport type Alarm = {\n  /**\n   * Date object or string representing an absolute time the alarm should occur.\n   * Overrides `relativeOffset` and `structuredLocation` if specified alongside either.\n   * @platform ios\n   */\n  absoluteDate?: string;\n  /**\n   * Number of minutes from the `startDate` of the calendar item that the alarm should occur.\n   * Use negative values to have the alarm occur before the `startDate`.\n   */\n  relativeOffset?: number;\n  // @docsMissing\n  structuredLocation?: AlarmLocation;\n  /**\n   * Method of alerting the user that this alarm should use; on iOS this is always a notification.\n   * Possible values: [`AlarmMethod`](#calendaralarmmethod).\n   * @platform android\n   */\n  method?: string;\n};\n\n// @needsAudit @docsMissing\nexport type AlarmLocation = {\n  /**\n   * @platform ios\n   */\n  title?: string;\n  proximity?: string;\n  radius?: number;\n  coords?: {\n    latitude?: number;\n    longitude?: number;\n  };\n};\n\nexport enum DayOfTheWeek {\n  Sunday = 1,\n  Monday = 2,\n  Tuesday = 3,\n  Wednesday = 4,\n  Thursday = 5,\n  Friday = 6,\n  Saturday = 7,\n}\n\nexport enum MonthOfTheYear {\n  January = 1,\n  February = 2,\n  March = 3,\n  April = 4,\n  May = 5,\n  June = 6,\n  July = 7,\n  August = 8,\n  September = 9,\n  October = 10,\n  November = 11,\n  December = 12,\n}\n\n// @needsAudit\n/**\n * A recurrence rule for events or reminders, allowing the same calendar item to recur multiple times.\n * This type is based on [the iOS interface](https://developer.apple.com/documentation/eventkit/ekrecurrencerule/1507320-initrecurrencewithfrequency)\n * which is in turn based on [the iCal RFC](https://tools.ietf.org/html/rfc5545#section-3.8.5.3)\n * so you can refer to those to learn more about this potentially complex interface.\n *\n * Not all of the combinations make sense. For example, when frequency is `DAILY`, setting `daysOfTheMonth` makes no sense.\n */\nexport type RecurrenceRule = {\n  /**\n   * How often the calendar item should recur.\n   * Possible values: [`Frequency`](#calendarfrequency).\n   */\n  frequency: string;\n  /**\n   * Interval at which the calendar item should recur. For example, an `interval: 2` with `frequency: DAILY`\n   * would yield an event that recurs every other day.\n   * @default 1\n   */\n  interval?: number;\n  /**\n   * Date on which the calendar item should stop recurring; overrides `occurrence` if both are specified.\n   */\n  endDate?: string | Date;\n  /**\n   * Number of times the calendar item should recur before stopping.\n   */\n  occurrence?: number;\n  /**\n   * The days of the week the event should recur on. An array of [`DaysOfTheWeek`](#daysoftheweek) object.\n   * @platform ios\n   */\n  daysOfTheWeek?: DaysOfTheWeek[];\n  /**\n   * The days of the month this event occurs on.\n   * `-31` to `31` (not including `0`). Negative indicates a value from the end of the range.\n   * This field is only valid for `Calendar.Frequency.Monthly`.\n   * @platform ios\n   */\n  daysOfTheMonth?: number[];\n  /**\n   * The months this event occurs on.\n   * This field is only valid for `Calendar.Frequency.Yearly`.\n   * @platform ios\n   */\n  monthsOfTheYear?: MonthOfTheYear[];\n  /**\n   * The weeks of the year this event occurs on.\n   * `-53` to `53` (not including `0`). Negative indicates a value from the end of the range.\n   * This field is only valid for `Calendar.Frequency.Yearly`.\n   * @platform ios\n   */\n  weeksOfTheYear?: number[];\n  /**\n   * The days of the year this event occurs on.\n   * `-366` to `366` (not including `0`). Negative indicates a value from the end of the range.\n   * This field is only valid for `Calendar.Frequency.Yearly`.\n   * @platform ios\n   */\n  daysOfTheYear?: number[];\n  /**\n   * TAn array of numbers that filters which recurrences to include. For example, for an event that\n   * recurs every Monday, passing 2 here will make it recur every other Monday.\n   * `-366` to `366` (not including `0`). Negative indicates a value from the end of the range.\n   * This field is only valid for `Calendar.Frequency.Yearly`.\n   * @platform ios\n   */\n  setPositions?: number[];\n};\n\n// @needsAudit\n/**\n * @platform ios\n */\nexport type DaysOfTheWeek = {\n  /**\n   * Sunday to Saturday - `DayOfTheWeek` enum.\n   */\n  dayOfTheWeek: DayOfTheWeek;\n  /**\n   * `-53` to `53` (`0` ignores this field, and a negative indicates a value from the end of the range).\n   */\n  weekNumber?: number;\n};\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\n\n// @needsAudit\n/**\n * Returns whether the Calendar API is enabled on the current device. This does not check the app permissions.\n *\n * @returns Async `boolean`, indicating whether the Calendar API is available on the current device.\n * Currently, this resolves `true` on iOS and Android only.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoCalendar.getCalendarsAsync;\n}\n\n// @needsAudit\n/**\n * Gets an array of calendar objects with details about the different calendars stored on the device.\n * @param entityType __iOS Only.__ Not required, but if defined, filters the returned calendars to\n * a specific entity type. Possible values are `Calendar.EntityTypes.EVENT` (for calendars shown in\n * the Calendar app) and `Calendar.EntityTypes.REMINDER` (for the Reminders app).\n * > **Note:** If not defined, you will need both permissions: **CALENDAR** and **REMINDERS**.\n * @return An array of [calendar objects](#calendar 'Calendar') matching the provided entity type (if provided).\n */\nexport async function getCalendarsAsync(entityType?: string): Promise<Calendar[]> {\n  if (!ExpoCalendar.getCalendarsAsync) {\n    throw new UnavailabilityError('Calendar', 'getCalendarsAsync');\n  }\n  if (!entityType) {\n    return ExpoCalendar.getCalendarsAsync(null);\n  }\n  return ExpoCalendar.getCalendarsAsync(entityType);\n}\n\n// @needsAudit\n/**\n * Creates a new calendar on the device, allowing events to be added later and displayed in the OS Calendar app.\n * @param details A map of details for the calendar to be created.\n * @return A string representing the ID of the newly created calendar.\n */\nexport async function createCalendarAsync(details: Partial<Calendar> = {}): Promise<string> {\n  if (!ExpoCalendar.saveCalendarAsync) {\n    throw new UnavailabilityError('Calendar', 'createCalendarAsync');\n  }\n  const color = details.color ? processColor(details.color) : undefined;\n  const newDetails = { ...details, id: undefined, color };\n  return ExpoCalendar.saveCalendarAsync(newDetails);\n}\n\n// @needsAudit\n/**\n * Updates the provided details of an existing calendar stored on the device. To remove a property,\n * explicitly set it to `null` in `details`.\n * @param id ID of the calendar to update.\n * @param details A map of properties to be updated.\n */\nexport async function updateCalendarAsync(\n  id: string,\n  details: Partial<Calendar> = {}\n): Promise<string> {\n  if (!ExpoCalendar.saveCalendarAsync) {\n    throw new UnavailabilityError('Calendar', 'updateCalendarAsync');\n  }\n  if (!id) {\n    throw new Error(\n      'updateCalendarAsync must be called with an id (string) of the target calendar'\n    );\n  }\n  const color = details.color ? processColor(details.color) : undefined;\n\n  if (Platform.OS === 'android') {\n    if (\n      details.hasOwnProperty('source') ||\n      details.hasOwnProperty('color') ||\n      details.hasOwnProperty('allowsModifications') ||\n      details.hasOwnProperty('allowedAvailabilities') ||\n      details.hasOwnProperty('isPrimary') ||\n      details.hasOwnProperty('ownerAccount') ||\n      details.hasOwnProperty('timeZone') ||\n      details.hasOwnProperty('allowedReminders') ||\n      details.hasOwnProperty('allowedAttendeeTypes') ||\n      details.hasOwnProperty('accessLevel')\n    ) {\n      console.warn(\n        'updateCalendarAsync was called with one or more read-only properties, which will not be updated'\n      );\n    }\n  } else {\n    if (\n      details.hasOwnProperty('source') ||\n      details.hasOwnProperty('type') ||\n      details.hasOwnProperty('entityType') ||\n      details.hasOwnProperty('allowsModifications') ||\n      details.hasOwnProperty('allowedAvailabilities')\n    ) {\n      console.warn(\n        'updateCalendarAsync was called with one or more read-only properties, which will not be updated'\n      );\n    }\n  }\n\n  const newDetails = { ...details, id, color };\n  return ExpoCalendar.saveCalendarAsync(newDetails);\n}\n\n// @needsAudit\n/**\n * Deletes an existing calendar and all associated events/reminders/attendees from the device. __Use with caution.__\n * @param id ID of the calendar to delete.\n */\nexport async function deleteCalendarAsync(id: string): Promise<void> {\n  if (!ExpoCalendar.deleteCalendarAsync) {\n    throw new UnavailabilityError('Calendar', 'deleteCalendarAsync');\n  }\n  if (!id) {\n    throw new Error(\n      'deleteCalendarAsync must be called with an id (string) of the target calendar'\n    );\n  }\n  return ExpoCalendar.deleteCalendarAsync(id);\n}\n\n// @needsAudit\n/**\n * Returns all events in a given set of calendars over a specified time period. The filtering has\n * slightly different behavior per-platform - on iOS, all events that overlap at all with the\n * `[startDate, endDate]` interval are returned, whereas on Android, only events that begin on or\n * after the `startDate` and end on or before the `endDate` will be returned.\n * @param calendarIds Array of IDs of calendars to search for events in.\n * @param startDate Beginning of time period to search for events in.\n * @param endDate End of time period to search for events in.\n * @return A promise which fulfils with an array of [`Event`](#event) objects matching the search criteria.\n */\nexport async function getEventsAsync(\n  calendarIds: string[],\n  startDate: Date,\n  endDate: Date\n): Promise<Event[]> {\n  if (!ExpoCalendar.getEventsAsync) {\n    throw new UnavailabilityError('Calendar', 'getEventsAsync');\n  }\n  if (!startDate) {\n    throw new Error('getEventsAsync must be called with a startDate (date) to search for events');\n  }\n  if (!endDate) {\n    throw new Error('getEventsAsync must be called with an endDate (date) to search for events');\n  }\n  if (!calendarIds || !calendarIds.length) {\n    throw new Error(\n      'getEventsAsync must be called with a non-empty array of calendarIds to search'\n    );\n  }\n  return ExpoCalendar.getEventsAsync(\n    stringifyIfDate(startDate),\n    stringifyIfDate(endDate),\n    calendarIds\n  );\n}\n\n// @needsAudit\n/**\n * Returns a specific event selected by ID. If a specific instance of a recurring event is desired,\n * the start date of this instance must also be provided, as instances of recurring events do not\n * have their own unique and stable IDs on either iOS or Android.\n * @param id ID of the event to return.\n * @param recurringEventOptions A map of options for recurring events.\n * @return A promise which fulfils with an [`Event`](#event) object matching the provided criteria, if one exists.\n */\nexport async function getEventAsync(\n  id: string,\n  recurringEventOptions: RecurringEventOptions = {}\n): Promise<Event> {\n  if (!ExpoCalendar.getEventByIdAsync) {\n    throw new UnavailabilityError('Calendar', 'getEventAsync');\n  }\n  if (!id) {\n    throw new Error('getEventAsync must be called with an id (string) of the target event');\n  }\n  if (Platform.OS === 'ios') {\n    return ExpoCalendar.getEventByIdAsync(id, recurringEventOptions.instanceStartDate);\n  } else {\n    return ExpoCalendar.getEventByIdAsync(id);\n  }\n}\n\n// @needsAudit\n/**\n * Creates a new event on the specified calendar.\n * @param calendarId ID of the calendar to create this event in.\n * @param eventData A map of details for the event to be created.\n * @return A promise which fulfils with a string representing the ID of the newly created event.\n */\nexport async function createEventAsync(\n  calendarId: string,\n  eventData: Partial<Event> = {}\n): Promise<string> {\n  if (!ExpoCalendar.saveEventAsync) {\n    throw new UnavailabilityError('Calendar', 'createEventAsync');\n  }\n  if (!calendarId) {\n    throw new Error('createEventAsync must be called with an id (string) of the target calendar');\n  }\n\n  const { id, ...details } = eventData;\n\n  if (Platform.OS === 'android') {\n    if (!details.startDate) {\n      throw new Error('createEventAsync requires a startDate (Date)');\n    }\n    if (!details.endDate) {\n      throw new Error('createEventAsync requires an endDate (Date)');\n    }\n  }\n\n  const newDetails = {\n    ...details,\n    calendarId,\n  };\n\n  return ExpoCalendar.saveEventAsync(stringifyDateValues(newDetails), {});\n}\n\n// @needsAudit\n/**\n * Updates the provided details of an existing calendar stored on the device. To remove a property,\n * explicitly set it to `null` in `details`.\n * @param id ID of the event to be updated.\n * @param details A map of properties to be updated.\n * @param recurringEventOptions A map of options for recurring events.\n */\nexport async function updateEventAsync(\n  id: string,\n  details: Partial<Event> = {},\n  recurringEventOptions: RecurringEventOptions = {}\n): Promise<string> {\n  if (!ExpoCalendar.saveEventAsync) {\n    throw new UnavailabilityError('Calendar', 'updateEventAsync');\n  }\n  if (!id) {\n    throw new Error('updateEventAsync must be called with an id (string) of the target event');\n  }\n\n  if (Platform.OS === 'ios') {\n    if (\n      details.hasOwnProperty('creationDate') ||\n      details.hasOwnProperty('lastModifiedDate') ||\n      details.hasOwnProperty('originalStartDate') ||\n      details.hasOwnProperty('isDetached') ||\n      details.hasOwnProperty('status') ||\n      details.hasOwnProperty('organizer')\n    ) {\n      console.warn(\n        'updateEventAsync was called with one or more read-only properties, which will not be updated'\n      );\n    }\n  }\n\n  const { futureEvents = false, instanceStartDate } = recurringEventOptions;\n  const newDetails = { ...details, id, instanceStartDate };\n  return ExpoCalendar.saveEventAsync(stringifyDateValues(newDetails), { futureEvents });\n}\n\n// @needsAudit\n/**\n * Deletes an existing event from the device. Use with caution.\n * @param id ID of the event to be deleted.\n * @param recurringEventOptions A map of options for recurring events.\n */\nexport async function deleteEventAsync(\n  id: string,\n  recurringEventOptions: RecurringEventOptions = {}\n): Promise<void> {\n  if (!ExpoCalendar.deleteEventAsync) {\n    throw new UnavailabilityError('Calendar', 'deleteEventAsync');\n  }\n  if (!id) {\n    throw new Error('deleteEventAsync must be called with an id (string) of the target event');\n  }\n  const { futureEvents = false, instanceStartDate } = recurringEventOptions;\n  return ExpoCalendar.deleteEventAsync({ id, instanceStartDate }, { futureEvents });\n}\n\n// @needsAudit\n/**\n * Gets all attendees for a given event (or instance of a recurring event).\n * @param id ID of the event to return attendees for.\n * @param recurringEventOptions A map of options for recurring events.\n * @return A promise which fulfils with an array of [`Attendee`](#attendee) associated with the\n * specified event.\n */\nexport async function getAttendeesForEventAsync(\n  id: string,\n  recurringEventOptions: RecurringEventOptions = {}\n): Promise<Attendee[]> {\n  if (!ExpoCalendar.getAttendeesForEventAsync) {\n    throw new UnavailabilityError('Calendar', 'getAttendeesForEventAsync');\n  }\n  if (!id) {\n    throw new Error(\n      'getAttendeesForEventAsync must be called with an id (string) of the target event'\n    );\n  }\n  const { instanceStartDate } = recurringEventOptions;\n  // Android only takes an ID, iOS takes an object\n  const params = Platform.OS === 'ios' ? { id, instanceStartDate } : id;\n  return ExpoCalendar.getAttendeesForEventAsync(params);\n}\n\n// @needsAudit\n/**\n * Creates a new attendee record and adds it to the specified event. Note that if `eventId` specifies\n * a recurring event, this will add the attendee to every instance of the event.\n * @param eventId ID of the event to add this attendee to.\n * @param details A map of details for the attendee to be created.\n * @return A string representing the ID of the newly created attendee record.\n * @platform android\n */\nexport async function createAttendeeAsync(\n  eventId: string,\n  details: Partial<Attendee> = {}\n): Promise<string> {\n  if (!ExpoCalendar.saveAttendeeForEventAsync) {\n    throw new UnavailabilityError('Calendar', 'createAttendeeAsync');\n  }\n  if (!eventId) {\n    throw new Error('createAttendeeAsync must be called with an id (string) of the target event');\n  }\n  if (!details.email) {\n    throw new Error('createAttendeeAsync requires an email (string)');\n  }\n  if (!details.role) {\n    throw new Error('createAttendeeAsync requires a role (string)');\n  }\n  if (!details.type) {\n    throw new Error('createAttendeeAsync requires a type (string)');\n  }\n  if (!details.status) {\n    throw new Error('createAttendeeAsync requires a status (string)');\n  }\n  const newDetails = { ...details, id: undefined };\n  return ExpoCalendar.saveAttendeeForEventAsync(newDetails, eventId);\n}\n\n// @needsAudit\n/**\n * Updates an existing attendee record. To remove a property, explicitly set it to `null` in `details`.\n * @param id ID of the attendee record to be updated.\n * @param details A map of properties to be updated.\n * @platform android\n */\nexport async function updateAttendeeAsync(\n  id: string,\n  details: Partial<Attendee> = {}\n): Promise<string> {\n  if (!ExpoCalendar.saveAttendeeForEventAsync) {\n    throw new UnavailabilityError('Calendar', 'updateAttendeeAsync');\n  }\n  if (!id) {\n    throw new Error('updateAttendeeAsync must be called with an id (string) of the target event');\n  }\n  const newDetails = { ...details, id };\n  return ExpoCalendar.saveAttendeeForEventAsync(newDetails, null);\n}\n\n// @needsAudit\n/**\n * Gets an instance of the default calendar object.\n * @return A promise resolving to the [Calendar](#calendar) object that is the user's default calendar.\n * @platform ios\n */\nexport async function getDefaultCalendarAsync(): Promise<Calendar> {\n  if (!ExpoCalendar.getDefaultCalendarAsync) {\n    throw new UnavailabilityError('Calendar', 'getDefaultCalendarAsync');\n  }\n  return ExpoCalendar.getDefaultCalendarAsync();\n}\n\n// @needsAudit\n/**\n * Deletes an existing attendee record from the device. __Use with caution.__\n * @param id ID of the attendee to delete.\n * @platform android\n */\nexport async function deleteAttendeeAsync(id: string): Promise<void> {\n  if (!ExpoCalendar.deleteAttendeeAsync) {\n    throw new UnavailabilityError('Calendar', 'deleteAttendeeAsync');\n  }\n  if (!id) {\n    throw new Error('deleteAttendeeAsync must be called with an id (string) of the target event');\n  }\n  return ExpoCalendar.deleteAttendeeAsync(id);\n}\n\n// @needsAudit\n/**\n * Returns a list of reminders matching the provided criteria. If `startDate` and `endDate` are defined,\n * returns all reminders that overlap at all with the [startDate, endDate] interval - i.e. all reminders\n * that end after the `startDate` or begin before the `endDate`.\n * @param calendarIds Array of IDs of calendars to search for reminders in.\n * @param status One of `Calendar.ReminderStatus.COMPLETED` or `Calendar.ReminderStatus.INCOMPLETE`.\n * @param startDate Beginning of time period to search for reminders in. Required if `status` is defined.\n * @param endDate End of time period to search for reminders in. Required if `status` is defined.\n * @return A promise which fulfils with an array of [`Reminder`](#reminder) objects matching the search criteria.\n * @platform ios\n */\nexport async function getRemindersAsync(\n  calendarIds: (string | null)[],\n  status: string | null,\n  startDate: Date,\n  endDate: Date\n): Promise<Reminder[]> {\n  if (!ExpoCalendar.getRemindersAsync) {\n    throw new UnavailabilityError('Calendar', 'getRemindersAsync');\n  }\n  if (status && !startDate) {\n    throw new Error(\n      'getRemindersAsync must be called with a startDate (date) to search for reminders'\n    );\n  }\n  if (status && !endDate) {\n    throw new Error(\n      'getRemindersAsync must be called with an endDate (date) to search for reminders'\n    );\n  }\n  if (!calendarIds || !calendarIds.length) {\n    throw new Error(\n      'getRemindersAsync must be called with a non-empty array of calendarIds to search'\n    );\n  }\n  return ExpoCalendar.getRemindersAsync(\n    stringifyIfDate(startDate) || null,\n    stringifyIfDate(endDate) || null,\n    calendarIds,\n    status || null\n  );\n}\n\n// @needsAudit\n/**\n * Returns a specific reminder selected by ID.\n * @param id ID of the reminder to return.\n * @return A promise which fulfils with a [`Reminder`](#reminder) matching the provided ID, if one exists.\n * @platform ios\n */\nexport async function getReminderAsync(id: string): Promise<Reminder> {\n  if (!ExpoCalendar.getReminderByIdAsync) {\n    throw new UnavailabilityError('Calendar', 'getReminderAsync');\n  }\n  if (!id) {\n    throw new Error('getReminderAsync must be called with an id (string) of the target reminder');\n  }\n  return ExpoCalendar.getReminderByIdAsync(id);\n}\n\n// @needsAudit\n/**\n * Creates a new reminder on the specified calendar.\n * @param calendarId ID of the calendar to create this reminder in (or `null` to add the calendar to\n * the OS-specified default calendar for reminders).\n * @param reminder A map of details for the reminder to be created\n * @return A promise which fulfils with a string representing the ID of the newly created reminder.\n * @platform ios\n */\nexport async function createReminderAsync(\n  calendarId: string | null,\n  reminder: Reminder = {}\n): Promise<string> {\n  if (!ExpoCalendar.saveReminderAsync) {\n    throw new UnavailabilityError('Calendar', 'createReminderAsync');\n  }\n\n  const { id, ...details } = reminder;\n  const newDetails = {\n    ...details,\n    calendarId: calendarId === null ? undefined : calendarId,\n  };\n  return ExpoCalendar.saveReminderAsync(stringifyDateValues(newDetails));\n}\n\n// @needsAudit\n/**\n * Updates the provided details of an existing reminder stored on the device. To remove a property,\n * explicitly set it to `null` in `details`.\n * @param id ID of the reminder to be updated.\n * @param details A map of properties to be updated.\n * @platform ios\n */\nexport async function updateReminderAsync(id: string, details: Reminder = {}): Promise<string> {\n  if (!ExpoCalendar.saveReminderAsync) {\n    throw new UnavailabilityError('Calendar', 'updateReminderAsync');\n  }\n  if (!id) {\n    throw new Error(\n      'updateReminderAsync must be called with an id (string) of the target reminder'\n    );\n  }\n\n  if (details.hasOwnProperty('creationDate') || details.hasOwnProperty('lastModifiedDate')) {\n    console.warn(\n      'updateReminderAsync was called with one or more read-only properties, which will not be updated'\n    );\n  }\n\n  const newDetails = { ...details, id };\n  return ExpoCalendar.saveReminderAsync(stringifyDateValues(newDetails));\n}\n\n// @needsAudit\n/**\n * Deletes an existing reminder from the device. __Use with caution.__\n * @param id ID of the reminder to be deleted.\n * @platform ios\n */\nexport async function deleteReminderAsync(id: string): Promise<void> {\n  if (!ExpoCalendar.deleteReminderAsync) {\n    throw new UnavailabilityError('Calendar', 'deleteReminderAsync');\n  }\n  if (!id) {\n    throw new Error(\n      'deleteReminderAsync must be called with an id (string) of the target reminder'\n    );\n  }\n  return ExpoCalendar.deleteReminderAsync(id);\n}\n\n// @needsAudit @docsMissing\n/**\n * @return A promise which fulfils with an array of [`Source`](#source) objects all sources for\n * calendars stored on the device.\n * @platform ios\n */\nexport async function getSourcesAsync(): Promise<Source[]> {\n  if (!ExpoCalendar.getSourcesAsync) {\n    throw new UnavailabilityError('Calendar', 'getSourcesAsync');\n  }\n  return ExpoCalendar.getSourcesAsync();\n}\n\n// @needsAudit\n/**\n * Returns a specific source selected by ID.\n * @param id ID of the source to return.\n * @return A promise which fulfils with an array of [`Source`](#source) object matching the provided\n * ID, if one exists.\n * @platform ios\n */\nexport async function getSourceAsync(id: string): Promise<Source> {\n  if (!ExpoCalendar.getSourceByIdAsync) {\n    throw new UnavailabilityError('Calendar', 'getSourceAsync');\n  }\n  if (!id) {\n    throw new Error('getSourceAsync must be called with an id (string) of the target source');\n  }\n  return ExpoCalendar.getSourceByIdAsync(id);\n}\n\n// @needsAudit\n/**\n * Sends an intent to open the specified event in the OS Calendar app.\n * @param id ID of the event to open.\n * @platform android\n */\nexport function openEventInCalendar(id: string): void {\n  if (!ExpoCalendar.openEventInCalendar) {\n    console.warn(`openEventInCalendar is not available on platform: ${Platform.OS}`);\n    return;\n  }\n  if (!id) {\n    throw new Error('openEventInCalendar must be called with an id (string) of the target event');\n  }\n  return ExpoCalendar.openEventInCalendar(parseInt(id, 10));\n} // Android\n\n// @needsAudit\n/**\n * @deprecated Use [`requestCalendarPermissionsAsync()`](#calendarrequestcalendarpermissionsasync) instead.\n */\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  console.warn(\n    'requestPermissionsAsync is deprecated. Use requestCalendarPermissionsAsync instead.'\n  );\n  return requestCalendarPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing user's calendars.\n * @return A promise that resolves to an object of type [`PermissionResponse`](#permissionresponse).\n */\nexport async function getCalendarPermissionsAsync(): Promise<PermissionResponse> {\n  if (!ExpoCalendar.getCalendarPermissionsAsync) {\n    throw new UnavailabilityError('Calendar', 'getCalendarPermissionsAsync');\n  }\n  return ExpoCalendar.getCalendarPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing user's reminders.\n * @return A promise that resolves to an object of type [`PermissionResponse`](#permissionresponse).\n * @platform ios\n */\nexport async function getRemindersPermissionsAsync(): Promise<PermissionResponse> {\n  if (!ExpoCalendar.getRemindersPermissionsAsync) {\n    throw new UnavailabilityError('Calendar', 'getRemindersPermissionsAsync');\n  }\n  return ExpoCalendar.getRemindersPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for accessing user's calendars.\n * @return A promise that resolves to an object of type [`PermissionResponse`](#permissionresponse).\n */\nexport async function requestCalendarPermissionsAsync(): Promise<PermissionResponse> {\n  if (!ExpoCalendar.requestCalendarPermissionsAsync) {\n    throw new UnavailabilityError('Calendar', 'requestCalendarPermissionsAsync');\n  }\n  return await ExpoCalendar.requestCalendarPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for accessing user's reminders.\n * @return A promise that resolves to an object of type [`PermissionResponse`](#permissionresponse).\n * @platform ios\n */\nexport async function requestRemindersPermissionsAsync(): Promise<PermissionResponse> {\n  if (!ExpoCalendar.requestRemindersPermissionsAsync) {\n    throw new UnavailabilityError('Calendar', 'requestRemindersPermissionsAsync');\n  }\n  return await ExpoCalendar.requestRemindersPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions to access the calendar.\n * This uses both `getCalendarPermissionsAsync` and `requestCalendarPermissionsAsync` to interact\n * with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Calendar.useCalendarPermissions();\n * ```\n */\nexport const useCalendarPermissions = createPermissionHook({\n  getMethod: getCalendarPermissionsAsync,\n  requestMethod: requestCalendarPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * Check or request permissions to access reminders.\n * This uses both `getRemindersPermissionsAsync` and `requestRemindersPermissionsAsync` to interact\n * with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Calendar.useRemindersPermissions();\n * ```\n */\nexport const useRemindersPermissions = createPermissionHook({\n  getMethod: getRemindersPermissionsAsync,\n  requestMethod: requestRemindersPermissionsAsync,\n});\n\nexport const EntityTypes = {\n  EVENT: 'event',\n  REMINDER: 'reminder',\n};\n\nexport const Frequency = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly',\n};\n\nexport const Availability = {\n  NOT_SUPPORTED: 'notSupported', // iOS\n  BUSY: 'busy',\n  FREE: 'free',\n  TENTATIVE: 'tentative',\n  UNAVAILABLE: 'unavailable', // iOS\n};\n\nexport const CalendarType = {\n  LOCAL: 'local',\n  CALDAV: 'caldav',\n  EXCHANGE: 'exchange',\n  SUBSCRIBED: 'subscribed',\n  BIRTHDAYS: 'birthdays',\n  UNKNOWN: 'unknown',\n}; // iOS\n\nexport const EventStatus = {\n  NONE: 'none',\n  CONFIRMED: 'confirmed',\n  TENTATIVE: 'tentative',\n  CANCELED: 'canceled',\n};\n\nexport const SourceType = {\n  LOCAL: 'local',\n  EXCHANGE: 'exchange',\n  CALDAV: 'caldav',\n  MOBILEME: 'mobileme',\n  SUBSCRIBED: 'subscribed',\n  BIRTHDAYS: 'birthdays',\n};\n\nexport const AttendeeRole = {\n  UNKNOWN: 'unknown', // iOS\n  REQUIRED: 'required', // iOS\n  OPTIONAL: 'optional', // iOS\n  CHAIR: 'chair', // iOS\n  NON_PARTICIPANT: 'nonParticipant', // iOS\n  ATTENDEE: 'attendee', // Android\n  ORGANIZER: 'organizer', // Android\n  PERFORMER: 'performer', // Android\n  SPEAKER: 'speaker', // Android\n  NONE: 'none', // Android\n};\n\nexport const AttendeeStatus = {\n  UNKNOWN: 'unknown', // iOS\n  PENDING: 'pending', // iOS\n  ACCEPTED: 'accepted',\n  DECLINED: 'declined',\n  TENTATIVE: 'tentative',\n  DELEGATED: 'delegated', // iOS\n  COMPLETED: 'completed', // iOS\n  IN_PROCESS: 'inProcess', // iOS\n  INVITED: 'invited', // Android\n  NONE: 'none', // Android\n};\n\nexport const AttendeeType = {\n  UNKNOWN: 'unknown', // iOS\n  PERSON: 'person', // iOS\n  ROOM: 'room', // iOS\n  GROUP: 'group', // iOS\n  RESOURCE: 'resource',\n  OPTIONAL: 'optional', // Android\n  REQUIRED: 'required', // Android\n  NONE: 'none', // Android\n};\n\nexport const AlarmMethod = {\n  ALARM: 'alarm',\n  ALERT: 'alert',\n  EMAIL: 'email',\n  SMS: 'sms',\n  DEFAULT: 'default',\n};\n\nexport const EventAccessLevel = {\n  CONFIDENTIAL: 'confidential',\n  PRIVATE: 'private',\n  PUBLIC: 'public',\n  DEFAULT: 'default',\n};\n\nexport const CalendarAccessLevel = {\n  CONTRIBUTOR: 'contributor',\n  EDITOR: 'editor',\n  FREEBUSY: 'freebusy',\n  OVERRIDE: 'override',\n  OWNER: 'owner',\n  READ: 'read',\n  RESPOND: 'respond',\n  ROOT: 'root',\n  NONE: 'none',\n};\n\nexport const ReminderStatus = {\n  COMPLETED: 'completed',\n  INCOMPLETE: 'incomplete',\n};\n\nfunction stringifyIfDate(date: any): any {\n  return date instanceof Date ? date.toISOString() : date;\n}\n\nfunction stringifyDateValues(obj: object): object {\n  return Object.keys(obj).reduce((acc, key) => {\n    const value = obj[key];\n    if (value != null && typeof value === 'object' && !(value instanceof Date)) {\n      if (Array.isArray(value)) {\n        return { ...acc, [key]: value.map(stringifyDateValues) };\n      }\n      return { ...acc, [key]: stringifyDateValues(value) };\n    }\n    acc[key] = stringifyIfDate(value);\n    return acc;\n  }, {});\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}